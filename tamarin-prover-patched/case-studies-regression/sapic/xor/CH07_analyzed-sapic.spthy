theory CH07 begin

// Function signature and definition of the equational theory E

builtins: xor
functions: check_rep/2, fst/1, get_rep/1, h/1, lh/1, pair/2,
           rep/2 [private], rh/1, rot/2, snd/1
equations:
    check_rep(rep(m, loc), loc) = m,
    fst(<x.1, x.2>) = x.1,
    get_rep(rep(m, loc)) = m,
    snd(<x.1, x.2>) = x.2

heuristic: p

rule (modulo E) Init_:
   [ ] --[ Init( ) ]-> [ State_( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_0_:
   [ State_( ) ] --> [ !Semistate_1( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_1_:
   [ !Semistate_1( ) ] --> [ State_1( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) new_k_1:
   [ State_1( ), Fr( ~k ) ] --> [ State_11( ~k ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) new_id_11:
   [ State_11( ~k ), Fr( ~id ) ] --> [ State_111( ~id, ~k ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_0_111:
   [ State_111( ~id, ~k ) ] --> [ !Semistate_1111( ~id, ~k ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_1_111:
   [ !Semistate_1111( ~id, ~k ) ] --> [ State_1111( ~id, ~k ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Par_1111:
   [ State_1111( ~id, ~k ) ]
  -->
   [ State_11111( ~id, ~k ), State_11112( ~id, ~k ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) new_r1_11111[color=#569dc0]:
   [ State_11111( ~id, ~k ), Fr( ~r1 ) ]
  -->
   [ State_111111( ~id, ~k, ~r1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_Challenger1_Reader__111111[color=#569dc0]:
   [ State_111111( ~id, ~k, ~r1 ) ]
  --[ Event( ), Challenge( ~r1, 'Reader' ) ]->
   [ State_1111111( ~id, ~k, ~r1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) out_r1_1111111[color=#569dc0]:
   [ State_1111111( ~id, ~k, ~r1 ) ]
  -->
   [ State_11111111( ~id, ~k, ~r1 ), Out( ~r1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) in_r2_x__11111111[color=#569dc0]:
   [ State_11111111( ~id, ~k, ~r1 ), In( <r2, x> ) ]
  -->
   [ State_111111111( ~id, ~k, ~r1, r2, x ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) if_eqx_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_0_111111111[color=#569dc0]:
   [ State_111111111( ~id, ~k, ~r1, r2, x ) ]
  --[ Pred_eq( x, lh((h((~k⊕~r1⊕r2))⊕rot(~id, h((~k⊕~r1⊕r2))))) ) ]->
   [ State_1111111111( ~id, ~k, ~r1, r2, x ) ]

  /*
  rule (modulo AC) if_eqx_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_0_111111111[color=#569dc0]:
     [ State_111111111( ~id, ~k, ~r1, r2, x.1 ) ]
    --[ Pred_eq( x.1, lh((h(x)⊕rot(~id, h(x)))) ) ]->
     [ State_1111111111( ~id, ~k, ~r1, r2, x.1 ) ]
    variants (modulo AC)
    1. ~k    = ~k.16
       ~r1   = ~r1.17
       r2    = ~k.16
       x     = ~r1.17
    
    2. ~k    = ~k.16
       ~r1   = ~r1.17
       r2    = ~r1.17
       x     = ~k.16
    
    3. ~k    = ~k.16
       ~r1   = ~r1.17
       r2    = zero
       x     = (~k.16⊕~r1.17)
    
    4. ~k    = ~k.16
       ~r1   = ~r1.17
       r2    = (~k.16⊕~r1.17)
       x     = zero
    
    5. ~k    = ~k.17
       ~r1   = ~k.17
       r2    = r2.19
       x     = r2.19
    
    6. ~k    = ~k.17
       ~r1   = ~r1.18
       r2    = r2.19
       x     = (~k.17⊕~r1.18⊕r2.19)
    
    7. ~k    = ~k.22
       ~r1   = ~r1.23
       r2    = (~k.22⊕~r1.23⊕x.29)
       x     = x.29
    
    8. ~k    = ~k.80
       ~r1   = ~r1.81
       r2    = (~r1.81⊕x.157)
       x     = (~k.80⊕x.157)
    
    9. ~k    = ~k.81
       ~r1   = ~r1.82
       r2    = (~k.81⊕x.159)
       x     = (~r1.82⊕x.159)
  */

rule (modulo E) if_eqx_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_1_111111111[color=#569dc0]:
   [ State_111111111( ~id, ~k, ~r1, r2, x ) ]
  --[ Pred_not_eq( x, lh((h((~k⊕~r1⊕r2))⊕rot(~id, h((~k⊕~r1⊕r2))))) ) ]->
   [ State_1111111112( ~id, ~k, ~r1, r2, x ) ]

  /*
  rule (modulo AC) if_eqx_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_1_111111111[color=#569dc0]:
     [ State_111111111( ~id, ~k, ~r1, r2, x.1 ) ]
    --[ Pred_not_eq( x.1, lh((h(x)⊕rot(~id, h(x)))) ) ]->
     [ State_1111111112( ~id, ~k, ~r1, r2, x.1 ) ]
    variants (modulo AC)
    1. ~k    = ~k.16
       ~r1   = ~r1.17
       r2    = ~k.16
       x     = ~r1.17
    
    2. ~k    = ~k.16
       ~r1   = ~r1.17
       r2    = ~r1.17
       x     = ~k.16
    
    3. ~k    = ~k.16
       ~r1   = ~r1.17
       r2    = zero
       x     = (~k.16⊕~r1.17)
    
    4. ~k    = ~k.16
       ~r1   = ~r1.17
       r2    = (~k.16⊕~r1.17)
       x     = zero
    
    5. ~k    = ~k.17
       ~r1   = ~k.17
       r2    = r2.19
       x     = r2.19
    
    6. ~k    = ~k.17
       ~r1   = ~r1.18
       r2    = r2.19
       x     = (~k.17⊕~r1.18⊕r2.19)
    
    7. ~k    = ~k.22
       ~r1   = ~r1.23
       r2    = (~k.22⊕~r1.23⊕x.29)
       x     = x.29
    
    8. ~k    = ~k.80
       ~r1   = ~r1.81
       r2    = (~r1.81⊕x.157)
       x     = (~k.80⊕x.157)
    
    9. ~k    = ~k.81
       ~r1   = ~r1.82
       r2    = (~k.81⊕x.159)
       x     = (~r1.82⊕x.159)
  */

rule (modulo E) event_Alivek_Tag__1111111111[color=#569dc0]:
   [ State_1111111111( ~id, ~k, ~r1, r2, x ) ]
  --[ Event( ), Alive( ~k, 'Tag' ) ]->
   [ State_11111111111( ~id, ~k, ~r1, r2, x ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_Responsek_Reader__11111111111[color=#569dc0]:
   [ State_11111111111( ~id, ~k, ~r1, r2, x ) ]
  --[ Event( ), Response( ~k, 'Reader' ) ]->
   [ State_111111111111( ~id, ~k, ~r1, r2, x ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_Running_T_R_k_XOR_r1_XOR_r2__111111111111[color=#569dc0]:
   [ State_111111111111( ~id, ~k, ~r1, r2, x ) ]
  --[ Event( ), Running( <'T', 'R', (~k⊕~r1⊕r2)> ) ]->
   [ State_1111111111111( ~id, ~k, ~r1, r2, x ) ]

  /*
  rule (modulo AC) event_Running_T_R_k_XOR_r1_XOR_r2__111111111111[color=#569dc0]:
     [ State_111111111111( ~id, ~k, ~r1, r2, x ) ]
    --[ Event( ), Running( <'T', 'R', z> ) ]->
     [ State_1111111111111( ~id, ~k, ~r1, r2, x ) ]
    variants (modulo AC)
    1. ~k    = ~k.11
       ~r1   = ~r1.12
       r2    = ~k.11
       z     = ~r1.12
    
    2. ~k    = ~k.11
       ~r1   = ~r1.12
       r2    = ~r1.12
       z     = ~k.11
    
    3. ~k    = ~k.11
       ~r1   = ~r1.12
       r2    = zero
       z     = (~k.11⊕~r1.12)
    
    4. ~k    = ~k.11
       ~r1   = ~r1.12
       r2    = (~k.11⊕~r1.12)
       z     = zero
    
    5. ~k    = ~k.12
       ~r1   = ~k.12
       r2    = r2.14
       z     = r2.14
    
    6. ~k    = ~k.12
       ~r1   = ~r1.13
       r2    = r2.14
       z     = (~k.12⊕~r1.13⊕r2.14)
    
    7. ~k    = ~k.16
       ~r1   = ~r1.17
       r2    = (~k.16⊕~r1.17⊕z.22)
       z     = z.22
    
    8. ~k    = ~k.18
       ~r1   = ~r1.19
       r2    = (~r1.19⊕x.33)
       z     = (~k.18⊕x.33)
    
    9. ~k    = ~k.19
       ~r1   = ~r1.20
       r2    = (~k.19⊕x.35)
       z     = (~r1.20⊕x.35)
  */

rule (modulo E) event_Commit_R_T_k_XOR_r1_XOR_r2__1111111111111[color=#569dc0]:
   [ State_1111111111111( ~id, ~k, ~r1, r2, x ) ]
  --[ Event( ), Commit( <'R', 'T', (~k⊕~r1⊕r2)> ) ]->
   [ State_11111111111111( ~id, ~k, ~r1, r2, x ) ]

  /*
  rule (modulo AC) event_Commit_R_T_k_XOR_r1_XOR_r2__1111111111111[color=#569dc0]:
     [ State_1111111111111( ~id, ~k, ~r1, r2, x ) ]
    --[ Event( ), Commit( <'R', 'T', z> ) ]->
     [ State_11111111111111( ~id, ~k, ~r1, r2, x ) ]
    variants (modulo AC)
    1. ~k    = ~k.11
       ~r1   = ~r1.12
       r2    = ~k.11
       z     = ~r1.12
    
    2. ~k    = ~k.11
       ~r1   = ~r1.12
       r2    = ~r1.12
       z     = ~k.11
    
    3. ~k    = ~k.11
       ~r1   = ~r1.12
       r2    = zero
       z     = (~k.11⊕~r1.12)
    
    4. ~k    = ~k.11
       ~r1   = ~r1.12
       r2    = (~k.11⊕~r1.12)
       z     = zero
    
    5. ~k    = ~k.12
       ~r1   = ~k.12
       r2    = r2.14
       z     = r2.14
    
    6. ~k    = ~k.12
       ~r1   = ~r1.13
       r2    = r2.14
       z     = (~k.12⊕~r1.13⊕r2.14)
    
    7. ~k    = ~k.16
       ~r1   = ~r1.17
       r2    = (~k.16⊕~r1.17⊕z.22)
       z     = z.22
    
    8. ~k    = ~k.18
       ~r1   = ~r1.19
       r2    = (~r1.19⊕x.33)
       z     = (~k.18⊕x.33)
    
    9. ~k    = ~k.19
       ~r1   = ~r1.20
       r2    = (~k.19⊕x.35)
       z     = (~r1.20⊕x.35)
  */

rule (modulo E) out_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11111111111111[color=#569dc0]:
   [ State_11111111111111( ~id, ~k, ~r1, r2, x ) ]
  -->
   [
   State_111111111111111( ~id, ~k, ~r1, r2, x ),
   Out( rh((h((~k⊕~r1⊕r2))⊕rot(~id, h((~k⊕~r1⊕r2))))) )
   ]

  /*
  rule (modulo AC) out_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11111111111111[color=#569dc0]:
     [ State_11111111111111( ~id, ~k, ~r1, r2, x.1 ) ]
    -->
     [
     State_111111111111111( ~id, ~k, ~r1, r2, x.1 ),
     Out( rh((h(x)⊕rot(~id, h(x)))) )
     ]
    variants (modulo AC)
    1. ~k    = ~k.16
       ~r1   = ~r1.17
       r2    = ~k.16
       x     = ~r1.17
    
    2. ~k    = ~k.16
       ~r1   = ~r1.17
       r2    = ~r1.17
       x     = ~k.16
    
    3. ~k    = ~k.16
       ~r1   = ~r1.17
       r2    = zero
       x     = (~k.16⊕~r1.17)
    
    4. ~k    = ~k.16
       ~r1   = ~r1.17
       r2    = (~k.16⊕~r1.17)
       x     = zero
    
    5. ~k    = ~k.17
       ~r1   = ~k.17
       r2    = r2.19
       x     = r2.19
    
    6. ~k    = ~k.17
       ~r1   = ~r1.18
       r2    = r2.19
       x     = (~k.17⊕~r1.18⊕r2.19)
    
    7. ~k    = ~k.22
       ~r1   = ~r1.23
       r2    = (~k.22⊕~r1.23⊕x.29)
       x     = x.29
    
    8. ~k    = ~k.80
       ~r1   = ~r1.81
       r2    = (~r1.81⊕x.157)
       x     = (~k.80⊕x.157)
    
    9. ~k    = ~k.81
       ~r1   = ~r1.82
       r2    = (~k.81⊕x.159)
       x     = (~r1.82⊕x.159)
  */

rule (modulo E) Zero_111111111111111[color=#569dc0]:
   [ State_111111111111111( ~id, ~k, ~r1, r2, x ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero_1111111112[color=#569dc0]:
   [ State_1111111112( ~id, ~k, ~r1, r2, x ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) in_r1_11112[color=#2cd719]:
   [ State_11112( ~id, ~k ), In( r1 ) ] --> [ State_111121( ~id, ~k, r1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) new_r2_111121[color=#2cd719]:
   [ State_111121( ~id, ~k, r1 ), Fr( ~r2 ) ]
  -->
   [ State_1111211( ~id, ~k, ~r2, r1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_Responsek_Tag__1111211[color=#2cd719]:
   [ State_1111211( ~id, ~k, ~r2, r1 ) ]
  --[ Event( ), Response( ~k, 'Tag' ) ]->
   [ State_11112111( ~id, ~k, ~r2, r1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_Challenger2_Tag__11112111[color=#2cd719]:
   [ State_11112111( ~id, ~k, ~r2, r1 ) ]
  --[ Event( ), Challenge( ~r2, 'Tag' ) ]->
   [ State_111121111( ~id, ~k, ~r2, r1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_Running_R_T_k_XOR_r1_XOR_r2__111121111[color=#2cd719]:
   [ State_111121111( ~id, ~k, ~r2, r1 ) ]
  --[ Event( ), Running( <'R', 'T', (~k⊕~r2⊕r1)> ) ]->
   [ State_1111211111( ~id, ~k, ~r2, r1 ) ]

  /*
  rule (modulo AC) event_Running_R_T_k_XOR_r1_XOR_r2__111121111[color=#2cd719]:
     [ State_111121111( ~id, ~k, ~r2, r1 ) ]
    --[ Event( ), Running( <'R', 'T', z> ) ]->
     [ State_1111211111( ~id, ~k, ~r2, r1 ) ]
    variants (modulo AC)
    1. ~k    = ~k.10
       ~r2   = ~r2.11
       r1    = ~k.10
       z     = ~r2.11
    
    2. ~k    = ~k.10
       ~r2   = ~r2.11
       r1    = ~r2.11
       z     = ~k.10
    
    3. ~k    = ~k.10
       ~r2   = ~r2.11
       r1    = zero
       z     = (~k.10⊕~r2.11)
    
    4. ~k    = ~k.10
       ~r2   = ~r2.11
       r1    = (~k.10⊕~r2.11)
       z     = zero
    
    5. ~k    = ~k.11
       ~r2   = ~k.11
       r1    = r1.13
       z     = r1.13
    
    6. ~k    = ~k.11
       ~r2   = ~r2.12
       r1    = r1.13
       z     = (~k.11⊕~r2.12⊕r1.13)
    
    7. ~k    = ~k.14
       ~r2   = ~r2.15
       r1    = (~k.14⊕~r2.15⊕z.19)
       z     = z.19
    
    8. ~k    = ~k.16
       ~r2   = ~r2.17
       r1    = (~r2.17⊕x.29)
       z     = (~k.16⊕x.29)
    
    9. ~k    = ~k.17
       ~r2   = ~r2.18
       r1    = (~k.17⊕x.31)
       z     = (~r2.18⊕x.31)
  */

rule (modulo E) out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111[color=#2cd719]:
   [ State_1111211111( ~id, ~k, ~r2, r1 ) ]
  -->
   [
   State_11112111111( ~id, ~k, ~r2, r1 ),
   Out( <~r2, lh((h((~k⊕~r2⊕r1))⊕rot(~id, h((~k⊕~r2⊕r1)))))> )
   ]

  /*
  rule (modulo AC) out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111[color=#2cd719]:
     [ State_1111211111( ~id, ~k, ~r2, r1 ) ]
    -->
     [
     State_11112111111( ~id, ~k, ~r2, r1 ),
     Out( <~r2, lh((h(x)⊕rot(~id, h(x))))> )
     ]
    variants (modulo AC)
    1. ~k    = ~k.15
       ~r2   = ~r2.16
       r1    = ~k.15
       x     = ~r2.16
    
    2. ~k    = ~k.15
       ~r2   = ~r2.16
       r1    = ~r2.16
       x     = ~k.15
    
    3. ~k    = ~k.15
       ~r2   = ~r2.16
       r1    = zero
       x     = (~k.15⊕~r2.16)
    
    4. ~k    = ~k.15
       ~r2   = ~r2.16
       r1    = (~k.15⊕~r2.16)
       x     = zero
    
    5. ~k    = ~k.16
       ~r2   = ~k.16
       r1    = r1.18
       x     = r1.18
    
    6. ~k    = ~k.16
       ~r2   = ~r2.17
       r1    = r1.18
       x     = (~k.16⊕~r2.17⊕r1.18)
    
    7. ~k    = ~k.20
       ~r2   = ~r2.21
       r1    = (~k.20⊕~r2.21⊕x.26)
       x     = x.26
    
    8. ~k    = ~k.73
       ~r2   = ~r2.74
       r1    = (~r2.74⊕x.143)
       x     = (~k.73⊕x.143)
    
    9. ~k    = ~k.74
       ~r2   = ~r2.75
       r1    = (~k.74⊕x.145)
       x     = (~r2.75⊕x.145)
  */

rule (modulo E) in_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11112111111[color=#2cd719]:
   [
   State_11112111111( ~id, ~k, ~r2, r1 ),
   In( rh((h((~k⊕~r2⊕r1))⊕rot(~id, h((~k⊕~r2⊕r1))))) )
   ]
  -->
   [ State_111121111111( ~id, ~k, ~r2, r1 ) ]

  /*
  rule (modulo AC) in_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11112111111[color=#2cd719]:
     [ State_11112111111( ~id, ~k, ~r2, r1 ), In( rh((h(x)⊕rot(~id, h(x)))) )
     ]
    -->
     [ State_111121111111( ~id, ~k, ~r2, r1 ) ]
    variants (modulo AC)
    1. ~k    = ~k.15
       ~r2   = ~r2.16
       r1    = ~k.15
       x     = ~r2.16
    
    2. ~k    = ~k.15
       ~r2   = ~r2.16
       r1    = ~r2.16
       x     = ~k.15
    
    3. ~k    = ~k.15
       ~r2   = ~r2.16
       r1    = zero
       x     = (~k.15⊕~r2.16)
    
    4. ~k    = ~k.15
       ~r2   = ~r2.16
       r1    = (~k.15⊕~r2.16)
       x     = zero
    
    5. ~k    = ~k.16
       ~r2   = ~k.16
       r1    = r1.18
       x     = r1.18
    
    6. ~k    = ~k.16
       ~r2   = ~r2.17
       r1    = r1.18
       x     = (~k.16⊕~r2.17⊕r1.18)
    
    7. ~k    = ~k.20
       ~r2   = ~r2.21
       r1    = (~k.20⊕~r2.21⊕x.26)
       x     = x.26
    
    8. ~k    = ~k.73
       ~r2   = ~r2.74
       r1    = (~r2.74⊕x.143)
       x     = (~k.73⊕x.143)
    
    9. ~k    = ~k.74
       ~r2   = ~r2.75
       r1    = (~k.74⊕x.145)
       x     = (~r2.75⊕x.145)
  */

rule (modulo E) event_Alivek_Reader__111121111111[color=#2cd719]:
   [ State_111121111111( ~id, ~k, ~r2, r1 ) ]
  --[ Event( ), Alive( ~k, 'Reader' ) ]->
   [ State_1111211111111( ~id, ~k, ~r2, r1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_Commit_T_R_k_XOR_r1_XOR_r2__1111211111111[color=#2cd719]:
   [ State_1111211111111( ~id, ~k, ~r2, r1 ) ]
  --[ Event( ), Commit( <'T', 'R', (~k⊕~r2⊕r1)> ) ]->
   [ State_11112111111111( ~id, ~k, ~r2, r1 ) ]

  /*
  rule (modulo AC) event_Commit_T_R_k_XOR_r1_XOR_r2__1111211111111[color=#2cd719]:
     [ State_1111211111111( ~id, ~k, ~r2, r1 ) ]
    --[ Event( ), Commit( <'T', 'R', z> ) ]->
     [ State_11112111111111( ~id, ~k, ~r2, r1 ) ]
    variants (modulo AC)
    1. ~k    = ~k.10
       ~r2   = ~r2.11
       r1    = ~k.10
       z     = ~r2.11
    
    2. ~k    = ~k.10
       ~r2   = ~r2.11
       r1    = ~r2.11
       z     = ~k.10
    
    3. ~k    = ~k.10
       ~r2   = ~r2.11
       r1    = zero
       z     = (~k.10⊕~r2.11)
    
    4. ~k    = ~k.10
       ~r2   = ~r2.11
       r1    = (~k.10⊕~r2.11)
       z     = zero
    
    5. ~k    = ~k.11
       ~r2   = ~k.11
       r1    = r1.13
       z     = r1.13
    
    6. ~k    = ~k.11
       ~r2   = ~r2.12
       r1    = r1.13
       z     = (~k.11⊕~r2.12⊕r1.13)
    
    7. ~k    = ~k.14
       ~r2   = ~r2.15
       r1    = (~k.14⊕~r2.15⊕z.19)
       z     = z.19
    
    8. ~k    = ~k.16
       ~r2   = ~r2.17
       r1    = (~r2.17⊕x.29)
       z     = (~k.16⊕x.29)
    
    9. ~k    = ~k.17
       ~r2   = ~r2.18
       r1    = (~k.17⊕x.31)
       z     = (~r2.18⊕x.31)
  */

rule (modulo E) Zero_11112111111111[color=#2cd719]:
   [ State_11112111111111( ~id, ~k, ~r2, r1 ) ] --> [ ]

  /* has exactly the trivial AC variant */

restriction predicate_eq:
  "∀ #i a b. (Pred_eq( a, b ) @ #i) ⇒ (a = b)"
  // safety formula

restriction predicate_not_eq:
  "∀ #i a b. (Pred_not_eq( a, b ) @ #i) ⇒ (¬(a = b))"
  // safety formula

restriction single_session:
  "∀ #i #j. ((Init( ) @ #i) ∧ (Init( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

lemma recentalive_tag:
  all-traces
  "∀ x #i.
    (Alive( x, 'Tag' ) @ #i) ⇒
    (∃ y #j #k.
      (((Challenge( y, 'Reader' ) @ #k) ∧ (Response( x, 'Tag' ) @ #j)) ∧
       (#k < #j)) ∧
      (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ x #i.
  (Alive( x, 'Tag' ) @ #i)
 ∧
  ∀ y #j #k.
   (Challenge( y, 'Reader' ) @ #k) ∧ (Response( x, 'Tag' ) @ #j)
  ⇒
   ((¬(#k < #j)) ∨ (¬(#j < #i)))"
*/
simplify
solve( Alive( x, 'Tag' ) @ #i )
  case event_Alivek_Tag__1111111111
  solve( State_1111111111( ~id, ~k, ~r1, r2, x ) ▶₀ #i )
    case if_eqx_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_0_111111111
    solve( !KU( lh((h(x)⊕rot(~id, h(x)))) ) @ #vk.2 )
      case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
      solve( splitEqs(1) )
        case split_case_7
        solve( !KU( (~r1⊕x) ) @ #vk.2 )
          case c_xor
          solve( splitEqs(2) )
            case split_case_1
            solve( !KU( ~r1 ) @ #vk.5 )
              case out_r1_1111111
              solve( !KU( ~x ) @ #vk.5 )
                case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
                SOLVED // trace found
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma recentalive_reader:
  all-traces
  "∀ x #i.
    (Alive( x, 'Reader' ) @ #i) ⇒
    (∃ y #j #k.
      (((Challenge( y, 'Tag' ) @ #k) ∧ (Response( x, 'Reader' ) @ #j)) ∧
       (#k < #j)) ∧
      (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ x #i.
  (Alive( x, 'Reader' ) @ #i)
 ∧
  ∀ y #j #k.
   (Challenge( y, 'Tag' ) @ #k) ∧ (Response( x, 'Reader' ) @ #j)
  ⇒
   ((¬(#k < #j)) ∨ (¬(#j < #i)))"
*/
simplify
solve( Alive( x, 'Reader' ) @ #i )
  case event_Alivek_Reader__111121111111
  solve( State_111121111111( ~id, ~k, ~r2, r1 ) ▶₀ #i )
    case in_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11112111111
    solve( !KU( rh((h(x)⊕rot(~id, h(x)))) ) @ #vk )
      case c_rh
      solve( !KU( (h(x)⊕rot(~id, h(x))) ) @ #vk.2 )
        case c_xor
        solve( !KU( rot(~id, h(x)) ) @ #vk.3 )
          case c_rot
          by solve( !KU( ~id ) @ #vk.5 )
        qed
      next
        case coerce
        solve( !KD( (h(x)⊕rot(~id, h(x))) ) ▶₀ #vk.1 )
          case out_r1_1111111
          by contradiction /* impossible chain */
        next
          case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
          solve( (#vl, 0) ~~> (#vk.1, 0) )
            case d_0_fst
            by contradiction /* impossible chain */
          next
            case d_0_snd
            by solve( (#vr.16, 0) ~~> (#vk.1, 0) )
          qed
        next
          case out_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11111111111111
          by solve( (#vl, 0) ~~> (#vk.1, 0) )
        qed
      qed
    next
      case out_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11111111111111
      solve( !KU( lh((h(x.2)⊕rot(~id, h(x.2)))) ) @ #vk.4 )
        case c_lh
        solve( !KU( (h(x.2)⊕rot(~id, h(x.2))) ) @ #vk.5 )
          case c_xor
          solve( !KU( rot(~id, h(x.1)) ) @ #vk.6 )
            case c_rot
            by solve( !KU( ~id ) @ #vk.8 )
          qed
        next
          case coerce
          solve( !KD( (h(x.1)⊕rot(~id, h(x.1))) ) ▶₀ #vk.2 )
            case out_r1_1111111
            by contradiction /* impossible chain */
          next
            case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
            solve( (#vl.1, 0) ~~> (#vk.2, 0) )
              case d_0_fst
              by contradiction /* impossible chain */
            next
              case d_0_snd
              by solve( (#vr.28, 0) ~~> (#vk.2, 0) )
            qed
          next
            case out_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11111111111111
            by solve( (#vl.1, 0) ~~> (#vk.2, 0) )
          qed
        qed
      next
        case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
        by contradiction /* from formulas */
      qed
    qed
  qed
qed

lemma noninjectiveagreement_tag:
  all-traces
  "∀ t #i.
    (Commit( <'T', 'R', t> ) @ #i) ⇒ (∃ #j. Running( <'T', 'R', t> ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ t #i.
  (Commit( <'T', 'R', t> ) @ #i)
 ∧
  ∀ #j. (Running( <'T', 'R', t> ) @ #j) ⇒ ⊥"
*/
simplify
solve( Commit( <'T', 'R', t> ) @ #i )
  case event_Commit_T_R_k_XOR_r1_XOR_r2__1111211111111
  solve( State_1111211111111( ~id, ~k, ~r2, r1 ) ▶₀ #i )
    case event_Alivek_Reader__111121111111
    solve( !KU( rh((h(x)⊕rot(~id, h(x)))) ) @ #vk )
      case c_rh
      solve( !KU( (h(x)⊕rot(~id, h(x))) ) @ #vk.2 )
        case c_xor
        solve( !KU( rot(~id, h(x)) ) @ #vk.3 )
          case c_rot
          by solve( !KU( ~id ) @ #vk.5 )
        qed
      next
        case coerce
        solve( !KD( (h(x)⊕rot(~id, h(x))) ) ▶₀ #vk.1 )
          case out_r1_1111111
          by contradiction /* impossible chain */
        next
          case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
          solve( (#vl, 0) ~~> (#vk.1, 0) )
            case d_0_fst
            by contradiction /* impossible chain */
          next
            case d_0_snd
            by solve( (#vr.17, 0) ~~> (#vk.1, 0) )
          qed
        next
          case out_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11111111111111
          by solve( (#vl, 0) ~~> (#vk.1, 0) )
        qed
      qed
    next
      case out_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11111111111111
      solve( !KU( lh((h(x.2)⊕rot(~id, h(x.2)))) ) @ #vk.4 )
        case c_lh
        solve( !KU( (h(x.2)⊕rot(~id, h(x.2))) ) @ #vk.5 )
          case c_xor
          solve( !KU( rot(~id, h(x.1)) ) @ #vk.6 )
            case c_rot
            by solve( !KU( ~id ) @ #vk.8 )
          qed
        next
          case coerce
          solve( !KD( (h(x.1)⊕rot(~id, h(x.1))) ) ▶₀ #vk.2 )
            case out_r1_1111111
            by contradiction /* impossible chain */
          next
            case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
            solve( (#vl.1, 0) ~~> (#vk.2, 0) )
              case d_0_fst
              by contradiction /* impossible chain */
            next
              case d_0_snd
              by solve( (#vr.29, 0) ~~> (#vk.2, 0) )
            qed
          next
            case out_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11111111111111
            by solve( (#vl.1, 0) ~~> (#vk.2, 0) )
          qed
        qed
      next
        case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
        solve( splitEqs(0) )
          case split_case_1
          by solve( !KU( ~k ) @ #vk.3 )
        next
          case split_case_2
          by contradiction /* from formulas */
        next
          case split_case_3
          solve( splitEqs(4) )
            case split_case_1
            solve( splitEqs(7) )
              case split_case_1
              by contradiction /* from formulas */
            next
              case split_case_2
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            by contradiction /* from formulas */
          qed
        next
          case split_case_4
          solve( splitEqs(7) )
            case split
            by contradiction /* from formulas */
          qed
        next
          case split_case_5
          solve( splitEqs(7) )
            case split
            by contradiction /* from formulas */
          qed
        next
          case split_case_6
          solve( !KU( (~k⊕~r2⊕z) ) @ #vk.3 )
            case c_xor_case_1
            solve( !KU( (~k⊕z) ) @ #vk.6 )
              case c_xor
              solve( !KU( ~r2 ) @ #vk.7 )
                case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
                by contradiction /* cyclic */
              qed
            next
              case coerce
              solve( !KD( (~k⊕z) ) ▶₀ #vk.3 )
                case out_r1_1111111
                by contradiction /* impossible chain */
              next
                case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
                solve( (#vl.2, 0) ~~> (#vk.3, 0) )
                  case d_0_fst
                  by contradiction /* impossible chain */
                next
                  case d_0_snd
                  by solve( (#vr.38, 0) ~~> (#vk.3, 0) )
                qed
              next
                case out_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11111111111111
                by solve( (#vl.2, 0) ~~> (#vk.3, 0) )
              qed
            qed
          next
            case c_xor_case_2
            solve( !KU( (~r2⊕z) ) @ #vk.6 )
              case c_xor
              by solve( !KU( ~k ) @ #vk.7 )
            next
              case coerce
              solve( !KD( (~r2⊕z) ) ▶₀ #vk.3 )
                case out_r1_1111111
                by contradiction /* impossible chain */
              next
                case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
                solve( (#vl.2, 0) ~~> (#vk.3, 0) )
                  case d_0_fst
                  by contradiction /* impossible chain */
                next
                  case d_0_snd
                  by solve( (#vr.38, 0) ~~> (#vk.3, 0) )
                qed
              next
                case out_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11111111111111
                by solve( (#vl.2, 0) ~~> (#vk.3, 0) )
              qed
            qed
          next
            case c_xor_case_3
            solve( !KU( (~k⊕~r2) ) @ #vk.7 )
              case c_xor
              solve( !KU( ~r2 ) @ #vk.8 )
                case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
                by contradiction /* cyclic */
              qed
            next
              case coerce
              solve( !KD( (~k⊕~r2) ) ▶₀ #vk.3 )
                case out_r1_1111111
                by contradiction /* impossible chain */
              next
                case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
                solve( (#vl.2, 0) ~~> (#vk.3, 0) )
                  case d_0_fst
                  by contradiction /* impossible chain */
                next
                  case d_0_snd
                  by solve( (#vr.38, 0) ~~> (#vk.3, 0) )
                qed
              next
                case out_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11111111111111
                by solve( (#vl.2, 0) ~~> (#vk.3, 0) )
              qed
            qed
          next
            case coerce
            solve( !KD( (~k⊕~r2⊕z) ) ▶₀ #vk.2 )
              case out_r1_1111111
              by contradiction /* impossible chain */
            next
              case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
              solve( (#vl.2, 0) ~~> (#vk.2, 0) )
                case d_0_fst
                by contradiction /* impossible chain */
              next
                case d_0_snd
                by solve( (#vr.38, 0) ~~> (#vk.2, 0) )
              qed
            next
              case out_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11111111111111
              by solve( (#vl.2, 0) ~~> (#vk.2, 0) )
            qed
          qed
        next
          case split_case_7
          solve( splitEqs(3) )
            case split
            solve( !KU( (~r2⊕x) ) @ #vk.3 )
              case c_xor
              solve( !KU( ~r2 ) @ #vk.7 )
                case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
                by contradiction /* cyclic */
              qed
            next
              case coerce
              solve( !KD( (~r2⊕x) ) ▶₀ #vk.2 )
                case out_r1_1111111
                by contradiction /* impossible chain */
              next
                case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
                solve( (#vl.2, 0) ~~> (#vk.2, 0) )
                  case d_0_fst
                  by contradiction /* impossible chain */
                next
                  case d_0_snd
                  by solve( (#vr.38, 0) ~~> (#vk.2, 0) )
                qed
              next
                case out_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11111111111111
                by solve( (#vl.2, 0) ~~> (#vk.2, 0) )
              qed
            qed
          qed
        next
          case split_case_8
          solve( splitEqs(3) )
            case split
            solve( !KU( (~k⊕x) ) @ #vk.3 )
              case c_xor
              by solve( !KU( ~k ) @ #vk.7 )
            next
              case coerce
              solve( !KD( (~k⊕x) ) ▶₀ #vk.2 )
                case out_r1_1111111
                by contradiction /* impossible chain */
              next
                case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
                solve( (#vl.2, 0) ~~> (#vk.2, 0) )
                  case d_0_fst
                  by contradiction /* impossible chain */
                next
                  case d_0_snd
                  by solve( (#vr.38, 0) ~~> (#vk.2, 0) )
                qed
              next
                case out_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11111111111111
                by solve( (#vl.2, 0) ~~> (#vk.2, 0) )
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma noninjectiveagreement_reader:
  all-traces
  "∀ t #i.
    (Commit( <'R', 'T', t> ) @ #i) ⇒ (∃ #j. Running( <'R', 'T', t> ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ t #i.
  (Commit( <'R', 'T', t> ) @ #i)
 ∧
  ∀ #j. (Running( <'R', 'T', t> ) @ #j) ⇒ ⊥"
*/
simplify
solve( Commit( <'R', 'T', t> ) @ #i )
  case event_Commit_R_T_k_XOR_r1_XOR_r2__1111111111111
  solve( State_1111111111111( ~id, ~k, ~r1, r2, x ) ▶₀ #i )
    case event_Running_T_R_k_XOR_r1_XOR_r2__111111111111
    solve( !KU( lh((h(x)⊕rot(~id, h(x)))) ) @ #vk.2 )
      case c_lh
      solve( !KU( (h(x)⊕rot(~id, h(x))) ) @ #vk.3 )
        case c_xor
        solve( !KU( rot(~id, h(x)) ) @ #vk.4 )
          case c_rot
          by solve( !KU( ~id ) @ #vk.6 )
        qed
      next
        case coerce
        solve( !KD( (h(x)⊕rot(~id, h(x))) ) ▶₀ #vk.1 )
          case out_r1_1111111
          by contradiction /* impossible chain */
        next
          case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
          solve( (#vl, 0) ~~> (#vk.1, 0) )
            case d_0_fst
            by contradiction /* impossible chain */
          next
            case d_0_snd
            by solve( (#vr.17, 0) ~~> (#vk.1, 0) )
          qed
        next
          case out_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11111111111111
          by solve( (#vl, 0) ~~> (#vk.1, 0) )
        qed
      qed
    next
      case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
      solve( splitEqs(0) )
        case split_case_1
        by solve( !KU( ~k ) @ #vk.2 )
      next
        case split_case_2
        by contradiction /* from formulas */
      next
        case split_case_3
        solve( splitEqs(3) )
          case split_case_1
          solve( splitEqs(4) )
            case split_case_1
            by contradiction /* from formulas */
          next
            case split_case_2
            by contradiction /* from formulas */
          qed
        next
          case split_case_2
          by contradiction /* from formulas */
        qed
      next
        case split_case_4
        solve( splitEqs(3) )
          case split
          by contradiction /* from formulas */
        qed
      next
        case split_case_5
        solve( splitEqs(4) )
          case split
          by contradiction /* from formulas */
        qed
      next
        case split_case_6
        solve( !KU( (~k⊕~r1⊕x) ) @ #vk.2 )
          case c_xor_case_1
          solve( !KU( (~k⊕x) ) @ #vk.4 )
            case c_xor
            by solve( !KU( ~k ) @ #vk.7 )
          next
            case coerce
            solve( !KD( (~k⊕x) ) ▶₀ #vk.2 )
              case out_r1_1111111
              by contradiction /* impossible chain */
            next
              case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
              solve( (#vl.1, 0) ~~> (#vk.2, 0) )
                case d_0_fst
                by contradiction /* impossible chain */
              next
                case d_0_snd
                by solve( (#vr.26, 0) ~~> (#vk.2, 0) )
              qed
            next
              case out_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11111111111111
              by solve( (#vl.1, 0) ~~> (#vk.2, 0) )
            qed
          qed
        next
          case c_xor_case_2
          solve( !KU( (~r1⊕x) ) @ #vk.4 )
            case c_xor
            by solve( !KU( ~k ) @ #vk.5 )
          next
            case coerce
            solve( !KD( (~r1⊕x) ) ▶₀ #vk.2 )
              case out_r1_1111111
              by contradiction /* impossible chain */
            next
              case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
              solve( (#vl.1, 0) ~~> (#vk.2, 0) )
                case d_0_fst
                by contradiction /* impossible chain */
              next
                case d_0_snd
                by solve( (#vr.26, 0) ~~> (#vk.2, 0) )
              qed
            next
              case out_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11111111111111
              by solve( (#vl.1, 0) ~~> (#vk.2, 0) )
            qed
          qed
        next
          case c_xor_case_3
          solve( !KU( (~k⊕~r1) ) @ #vk.5 )
            case c_xor
            by solve( !KU( ~k ) @ #vk.7 )
          next
            case coerce
            solve( !KD( (~k⊕~r1) ) ▶₀ #vk.2 )
              case out_r1_1111111
              by contradiction /* impossible chain */
            next
              case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
              solve( (#vl.1, 0) ~~> (#vk.2, 0) )
                case d_0_fst
                by contradiction /* impossible chain */
              next
                case d_0_snd
                by solve( (#vr.26, 0) ~~> (#vk.2, 0) )
              qed
            next
              case out_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11111111111111
              by solve( (#vl.1, 0) ~~> (#vk.2, 0) )
            qed
          qed
        next
          case coerce
          solve( !KD( (~k⊕~r1⊕x) ) ▶₀ #vk.1 )
            case out_r1_1111111
            by contradiction /* impossible chain */
          next
            case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
            solve( (#vl.1, 0) ~~> (#vk.1, 0) )
              case d_0_fst
              by contradiction /* impossible chain */
            next
              case d_0_snd
              by solve( (#vr.26, 0) ~~> (#vk.1, 0) )
            qed
          next
            case out_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11111111111111
            by solve( (#vl.1, 0) ~~> (#vk.1, 0) )
          qed
        qed
      next
        case split_case_7
        solve( splitEqs(2) )
          case split
          solve( !KU( (~r1⊕x) ) @ #vk.2 )
            case c_xor
            solve( splitEqs(3) )
              case split_case_1
              by contradiction /* from formulas */
            next
              case split_case_2
              by contradiction /* from formulas */
            next
              case split_case_3
              by contradiction /* from formulas */
            qed
          next
            case coerce
            solve( !KD( (~r1⊕x) ) ▶₀ #vk.1 )
              case out_r1_1111111
              by contradiction /* impossible chain */
            next
              case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
              solve( (#vl.1, 0) ~~> (#vk.1, 0) )
                case d_0_fst
                by contradiction /* impossible chain */
              next
                case d_0_snd
                by solve( (#vr.26, 0) ~~> (#vk.1, 0) )
              qed
            next
              case out_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11111111111111
              by solve( (#vl.1, 0) ~~> (#vk.1, 0) )
            qed
          qed
        qed
      next
        case split_case_8
        solve( splitEqs(2) )
          case split
          solve( !KU( (~k⊕x) ) @ #vk.2 )
            case c_xor
            by solve( !KU( ~k ) @ #vk.5 )
          next
            case coerce
            solve( !KD( (~k⊕x) ) ▶₀ #vk.1 )
              case out_r1_1111111
              by contradiction /* impossible chain */
            next
              case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
              solve( (#vl.1, 0) ~~> (#vk.1, 0) )
                case d_0_fst
                by contradiction /* impossible chain */
              next
                case d_0_snd
                by solve( (#vr.26, 0) ~~> (#vk.1, 0) )
              qed
            next
              case out_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11111111111111
              by solve( (#vl.1, 0) ~~> (#vk.1, 0) )
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma executable:
  exists-trace
  "∃ x #i #j.
    ((Alive( x, 'Reader' ) @ #i) ∧ (Response( x, 'Tag' ) @ #j)) ∧
    (¬(∃ #k. (Response( x, 'Tag' ) @ #k) ∧ (¬(#j = #k))))"
/*
guarded formula characterizing all satisfying traces:
"∃ x #i #j.
  (Alive( x, 'Reader' ) @ #i) ∧ (Response( x, 'Tag' ) @ #j)
 ∧
  ∀ #k. (Response( x, 'Tag' ) @ #k) ⇒ #j = #k"
*/
simplify
solve( Alive( x, 'Reader' ) @ #i )
  case event_Alivek_Reader__111121111111
  solve( State_111121111111( ~id, ~k, ~r2, r1 ) ▶₀ #i )
    case in_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11112111111
    solve( Response( ~k, 'Tag' ) @ #j )
      case event_Responsek_Tag__1111211
      solve( !KU( rh((h(x)⊕rot(~id, h(x)))) ) @ #vk )
        case out_rhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k_11111111111111
        solve( !KU( lh((h(x.2)⊕rot(~id, h(x.2)))) ) @ #vk.4 )
          case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
          solve( splitEqs(1) )
            case split_case_3
            solve( splitEqs(4) )
              case split_case_1
              solve( !KU( ~r1 ) @ #vk.3 )
                case out_r1_1111111
                solve( !KU( ~r2 ) @ #vk.4 )
                  case out_r2_lhrotid_hr1_XOR_r2_XOR_k_XOR_hr1_XOR_r2_XOR_k__1111211111
                  SOLVED // trace found
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

/* All well-formedness checks were successful. */

end
/* Output
maude tool: 'maude'
 checking version: 2.7.1. OK.
 checking installation: OK.
SAPIC tool: 'sapic'
Checking availablity ... OK.


analyzing: case-studies-sapic-regression/xor/CH07.spthy

------------------------------------------------------------------------------
analyzed: case-studies-sapic-regression/xor/CH07.spthy

  output:          case-studies-sapic-regression/xor/CH07.spthy.tmp
  processing time: 6.183740953s
  recentalive_tag (all-traces): falsified - found trace (10 steps)
  recentalive_reader (all-traces): verified (24 steps)
  noninjectiveagreement_tag (all-traces): verified (87 steps)
  noninjectiveagreement_reader (all-traces): verified (77 steps)
  executable (exists-trace): verified (11 steps)

------------------------------------------------------------------------------

==============================================================================
summary of summaries:

analyzed: case-studies-sapic-regression/xor/CH07.spthy

  output:          case-studies-sapic-regression/xor/CH07.spthy.tmp
  processing time: 6.183740953s
  recentalive_tag (all-traces): falsified - found trace (10 steps)
  recentalive_reader (all-traces): verified (24 steps)
  noninjectiveagreement_tag (all-traces): verified (87 steps)
  noninjectiveagreement_reader (all-traces): verified (77 steps)
  executable (exists-trace): verified (11 steps)

==============================================================================
*/
